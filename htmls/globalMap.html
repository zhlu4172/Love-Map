<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cesium Globe with Geoapify API</title>
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.99/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.99/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
  <style>
    html, body, #cesiumContainer {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
  </style>
</head>
<body>
  <div id="cesiumContainer"></div>
  <script>
    // Set your Cesium Ion Access Token
    Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJhOTk4ZDczYy0wZWVkLTQ3NDItODlmNi04N2UzYmRmYzE3ZjkiLCJpZCI6MjYwMDM3LCJpYXQiOjE3MzMzMTA5ODB9.ppiULD5fjIzqLYkSUXh-QG500EkmcwJk6q9NQrbZupc'; // Replace with your valid Cesium Ion Access Token

    // Initialize the Cesium Viewer
    const viewer = new Cesium.Viewer('cesiumContainer', {
      terrainProvider: Cesium.createWorldTerrain(),
      imageryProvider: new Cesium.IonImageryProvider({ assetId: 3 }), // Bing Maps Aerial
      baseLayerPicker: false,
      timeline: false,
      animation: false,
      fullscreenButton: true,
    });

    console.log = function (message) { window.webkit.messageHandlers.iosListener.postMessage(message); };
    console.error = function (error) { window.webkit.messageHandlers.iosListener.postMessage("Error: " + error); };
    console.warn = function (warning) { window.webkit.messageHandlers.iosListener.postMessage("Warning: " + warning); };

    console.log('Cesium Viewer Initialized');

    // Function to fetch city boundary using Geoapify Boundaries API
    async function fetchCityBoundary(cityName) {
      const apiKey = '90fdce55c4f34421a6f4ade4cfadeb84'; // Your Geoapify API key
      const url = `https://api.geoapify.com/v1/boundaries?name=${encodeURIComponent(cityName)}&format=geojson&apiKey=${apiKey}`;
      console.log(`Fetching boundary for ${cityName} from Geoapify API: ${url}`);

      try {
        const response = await fetch(url);
        if (!response.ok) {
          console.error(`Error: Geoapify API responded with status ${response.status}`);
          return null;
        }

        const data = await response.json();
        if (data.features && data.features.length > 0) {
          return data.features[0]; // Return the first feature (boundary)
        } else {
          console.warn(`No boundary found for ${cityName}`);
          return null;
        }
      } catch (error) {
        console.error(`Error fetching boundary for ${cityName}:`, error);
        return null;
      }
    }

    // Function to load and display city boundaries
    async function loadGeoJSONWithBoundaries(cities) {
      const features = [];

      for (const city of cities) {
        console.log(`Processing city: ${city.name}`);
        const boundaryFeature = await fetchCityBoundary(city.name);
        if (boundaryFeature) {
          features.push(boundaryFeature);
        } else {
          console.warn(`Skipping ${city.name} as no boundary was found.`);
        }
      }

      const geoJSON = {
        type: "FeatureCollection",
        features: features,
      };

      console.log("Final GeoJSON with boundaries:", geoJSON);

      // Load GeoJSON into Cesium
      const dataSource = Cesium.GeoJsonDataSource.load(geoJSON, {
        stroke: Cesium.Color.BLUE,
        fill: Cesium.Color.CYAN.withAlpha(0.4),
        strokeWidth: 2,
      });

      viewer.dataSources.add(dataSource);

      if (features.length > 0) {
        dataSource.then((ds) => viewer.flyTo(ds));
      }
    }

    // Listen for messages from Swift to load GeoJSON
    window.addEventListener('message', (event) => {
            console.log('Received GeoJSON data:', event.data);

            try {
                // Parse the received GeoJSON data
                const geoJSONData = JSON.parse(event.data);

                // Load the GeoJSON data into Cesium
                const dataSource = Cesium.GeoJsonDataSource.load(geoJSONData, {
                    stroke: Cesium.Color.BLUE,
                    fill: Cesium.Color.CYAN.withAlpha(0.4),
                    strokeWidth: 2
                });

                viewer.dataSources.add(dataSource);

                // Automatically fly to the loaded GeoJSON area
                dataSource.then((ds) => {
                    viewer.flyTo(ds).then(() => {
                        console.log('Successfully flew to GeoJSON data.');
                    });
                }).catch((error) => {
                    console.error('Error flying to GeoJSON data:', error);
                });

            } catch (error) {
                console.error('Error processing GeoJSON data:', error);
            }
        });

  </script>
</body>
</html>
